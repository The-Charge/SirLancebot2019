// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc2619.SirLancebot2016;

import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.Sendable;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;

import org.usfirst.frc2619.SirLancebot2016.commands.*;
import org.usfirst.frc2619.SirLancebot2016.subsystems.*;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the IterativeRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */
public class Robot extends IterativeRobot {

	Command autonomousCommand;

	public static OI oi;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static DriveTrain driveTrain;
    public static GearShift gearShift;
    //public static GyroSubsystem gyroSubsystem;
    //public static CameraSubsystem cameraSubsystem;
    public static Plunger plunger;
    public static ShooterMotors shooterMotors;
    public static Collector collector;
    public static Arms arms;
    public static Wrist wrist;
    public static ShooterPivot shooterPivot;
    public static BallSensor ballSensor;
    //public static VisionLights visionLights;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	public static boolean xboxcontrol;
	public static SendableChooser<Integer> driveControl;
	public static int direction;

	/**
	 * This function is run when the robot is first started up and should be
	 * used for any initialization code.
	 */
	public void robotInit() {

		RobotMap.init();
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        driveTrain = new DriveTrain();
        gearShift = new GearShift();
        //gyroSubsystem = new GyroSubsystem();
        //cameraSubsystem = new CameraSubsystem();
        plunger = new Plunger();
        shooterMotors = new ShooterMotors();
        collector = new Collector();
        arms = new Arms();
        wrist = new Wrist();
        shooterPivot = new ShooterPivot();
        ballSensor = new BallSensor();
		//visionLights = new VisionLights();
		xboxcontrol = false;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
		SmartDashboard.putData(driveTrain);
		driveControl = new SendableChooser<Integer>();
		driveControl.addDefault("Traditional", (Integer) (3));
        driveControl.addObject("Xbox Control", (Integer) (1));
        SmartDashboard.putData("Drive Control", driveControl);
		// OI must be constructed after subsystems. If the OI creates Commands
		// (which it very likely will), subsystems are not guaranteed to be
		// constructed yet. Thus, their requires() statements may grab null
		// pointers. Bad news. Don't move it.		
		oi = new OI();

		// instantiate the command used for the autonomous period
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

        //autonomousCommand = new AutonomousCG();

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
		
	}

	/**
	 * This function is called when the disabled button is hit. You can use it
	 * to reset subsystems before shutting down.
	 */
	public void disabledInit() {

	}

	public void disabledPeriodic() {
		Scheduler.getInstance().run();
	}

	public void autonomousInit() {

		autonomousCommand = (Command) oi.autonCommand.getSelected();

		if (autonomousCommand != null)
			autonomousCommand.start();

	}

	/**
	 * This function is called periodically during autonomous
	 */
	public void autonomousPeriodic() {
		Scheduler.getInstance().run();
	}

	public void teleopInit() {
		// This makes sure that the autonomous stops running when
		// teleop starts running. If you want the autonomous to
		// continue until interrupted by another command, remove
		// this line or comment it out.
		if (autonomousCommand != null)
			autonomousCommand.cancel();
	}

	/**
	 * This function is called periodically during operator control
	 */
	public void teleopPeriodic() {
		Scheduler.getInstance().run();

		// Subsystem commands to SD
		if (Robot.arms.getCurrentCommand() != null)
			SmartDashboard.putString("Arms Command", Robot.arms
					.getCurrentCommand().toString());
		SmartDashboard.putString("BallSensor Command", Robot.ballSensor
				.getCurrentCommand().toString());
		//SmartDashboard.putString("Camara Command", Robot.cameraSubsystem
				///.getCurrentCommand().toString());
		if (Robot.collector.getCurrentCommand() != null)
			SmartDashboard.putString("Collector Command", Robot.collector
					.getCurrentCommand().toString());
		SmartDashboard.putString("DriveTrain Command", Robot.driveTrain
				.getCurrentCommand().toString());
		SmartDashboard.putString("GearShift Command", Robot.gearShift
				.getCurrentCommand().toString());
		//SmartDashboard.putString("Gyro Command", Robot.gyroSubsystem
			//	.getCurrentCommand().toString());
		if (Robot.plunger.getCurrentCommand() != null)
			SmartDashboard.putString("Plunger Command", Robot.plunger
					.getCurrentCommand().toString());
		SmartDashboard.putString("ShooterMotors Command", Robot.shooterMotors
				.getCurrentCommand().toString());
		if (Robot.shooterPivot.getCurrentCommand() != null)
			SmartDashboard.putString("ShooterPivot Command", Robot.shooterPivot
					.getCurrentCommand().toString());
		
	
		direction = Robot.oi.getDpad();
		System.out.println(direction);
		
		if (direction != -2 && direction != -1){

			if (direction == 0)
			{
			   
			}

			if (direction == 90)
			{
			System.out.print("Hello");
			  if (Robot.shooterPivot.shooterUp)
					System.out.print("Lower");
					new LowerShooter();
				else new LiftShooter();
			} 

			if (direction == 180)
			{
			   if (Robot.wrist.wristbool)
					new WristDown();
				else new WristUp();
			}
			if (direction == 270)
			{
			   if(Robot.arms.status)
					new LowerArms();
				else new LiftArms();
			
			}
		}



		}

	/**
	 * This function is called periodically during test mode
	 */
	public void testPeriodic() {
		LiveWindow.run();
	}
}
